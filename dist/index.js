import{decode as o,encode as a}from"@the-minimal/protocol";var $=t=>({type:t.type,path:t.path,headers:t.headers??{},input:{encode:e=>a(t.input,e),decode:e=>o(t.input,e)},output:{encode:e=>a(t.output,e),decode:e=>o(t.output,e)}}),c=(t,e)=>({contract:t,handler:async u=>{let n=await u.arrayBuffer(),r=t.input.decode(n),p=await e(r),s=t.output.encode(p);return new Response(s,{status:200})}}),i=(t,e)=>async u=>{let r=await(await fetch(`${t}${e.path}`,{method:e.type==="query"?"GET":"POST",headers:{...e.headers,"content-type":"application/octet-stream"},body:e.input.encode(u)})).arrayBuffer();return e.output.decode(r)},d=new Map,l=t=>{for(let e=0;e<t.length;++e)d.set(`${t[e].contract.type}:${t[e].contract.path}`,t[e])},f=t=>{let e=new URL(t.url),u=`${t.method==="GET"?"query":"mutation"}:${e.pathname}`,n=d.get(u);return n?n.handler(t):new Response(null,{status:404,statusText:"Procedure not found"})};export{f as callProcedure,i as protocolClient,$ as protocolContract,c as protocolProcedure,l as registerProcedures};
